ER图组成：实体、属性、联系
# 数据库范式
* 1NF:属性不可再分割
* 2NF：1NF的基础上，消除了非主属性对于码的部分函数依赖
* 3NF：2NF的基础上，消除了非主属性对于码的传递函数依赖
# drop、delete、truncate区别
* drop（丢弃数据）：直接删除表 DDL 数据定义语言（立即生效，无法回滚）
* truncate：清空数据 DDL
* delete：删除数据 DML 数据操控语言

Order by 必须放在Where语句后
# MyISAM和InnoDB有什么区别
* InnoDB支持行级锁，MyISAM不支持，只支持表级别的锁粒度。
* MyISAM不提供事务支持。InnoDB提供事务支持，实现了SQL标准定义了四个隔离级别。
* MyISAM不支持外键，而InnoDB支持。
* MyISAM不支持MVVC,而InnoDB支持。
* 虽然两者都是用B+Tree作为索引，但是两者的实现方式不同。
* MyISAM不支持数据库异常崩溃后的安全恢复，而InnoDB支持。
* InnoDB的性能比MyISAM更强大。

# 数据库索引
索引是一种用于快速查找和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。
相当于书的目录，常见索引结构有:B树，B+树和HASH、红黑树。MySQL中，InnoDB还是Myksam，都使用B+树作为索引结构。
# 索引的优缺点
* 优点：
  * 使用索引可以大大加快数据的检索速度（大大减少检索的数据量），这也是创建索引的最主要的原因。
  * 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
* 缺点：
  * 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态修改，会降低SQL执行效率。
  * 索引需要使用物理文件存储，也会耗费一定空间。、
* 多数情况下，索引查询比全盘扫描快，但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。
# 索引底层结构
* Hash表：通过Key快速取出Value。缺点，Hash不支持顺序和范围查询。
* B树&B+树：B（Balance）
  * B树的所有节点既存放键（Key）也存放数据（data），而B+树只有叶子节点存放Key和data，其他节点只存放key。
  * B树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
  * B树的检索过程相当于对范围内的每个节点的关键字做二分查找，可能没有到达叶子节点，检索就结束了。而B+树的检索效率很稳定，任何查找都是从根节点到叶子节点的过程，叶子系欸但的顺序检测很明显。
# 索引类型
* 聚簇索引：索引结构和数据一起存放的索引，InnoDB中的主键索引就属于聚簇索引
  * 优点：
    * 查询速度非常快
    * 对排序查找和范围查找优化
  * 缺点：
    * 依赖于有序的数据
    * 更新代价大
* 非聚簇索引：索引结构和数据分开存放的索引，二级索引就属于非聚簇索引。Mysql的MyISAM引擎，不管主键还是非主键，使用的都是非聚簇索引。
  * 优点：
    * 更新代价比聚簇索引要小。
  * 缺点：
    * 依赖于有序的数据
    * 可能会二次查询
  
# 二级索引
* 唯一索引(Unique Key) ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率
* 普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。
* 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。
* 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。
# 事务
事务是逻辑上的一组操作，要么都执行，要么都不执行
# ACID
* A 原子性
* C 一致性
* I 隔离性
* D 持久性

# SQL标准定义了那些事务？
隔离级别是基于锁和MVCC机制共同实现的
* READ-UNCOMMITTED（读取未提交）
* READ-COMMITTED（读取已提交）（MVCC）
* REPEATABLE-READ（可重复读）（MVCC）
* SERIALIZABLE（可串行化）（锁）
  
# InnoDB有哪几类行锁
* 记录锁（Record Lock）：
* 间隙锁（Gap Lock）：锁定一个范围
* 临键锁（Next-Key Lock）：记录锁+间隙锁

# EXPLAIN执行结果中的TYPE
* system 表只有一行数据
* const 只有一行匹配数据
* eq_ref join方式，主键或唯一索引的所有字段作为连表条件
* ref 普通索引作为查找条件
* index_merge 多个索引
* range 对索引列进行范围查找
* index 索引扫描
* ALL 全表扫描
# 自增主键不连续的情况：
1. 自增初始值和自增补偿设置不为1
2. 唯一键冲突
3. 事务回滚
4. 批量插入数据（insert……select）
# Datatime 和 Timestamp选择
1. Datatime没有时区信息，Timestamp包含时区信息
2. Datatime存储8个字节，Timestamp 存储4个字节
3. 时间戳，四字节
# 隐式转换
1. 当操作符左右两边的数据类型不一致时，会发生隐式转换
2. 当where查询操作左边为数值类型时发生了隐式转换，那么效率影响不大
3. 当where查询操作左边为字符类型时发生隐式转换，导致索引失效，全盘扫描效率下降
4. 字符串转换为数值时，非数字开头会变为0，以数字为开头会截取至第一个不为字符的数字
# varChar 和 Char的区别
1. char的长度不变固定（时间效率），vaChar的长度是可变的（空间效率）
2. 存取速度不同：char存取速度较快。
3. 存储方式不同：char 英文一个字节，汉字两个字节；varchar 英文两个字节，中文两个字节

# Redis为什么这么快
1. Redis基于内存，内存的访问速度是磁盘的上千倍；
2. Redis基于Reactor模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和IO多路服用；
3. Redis内置了多种优化过后的数据结构实现，性能非常高。

# Redis单线程模型--基于Reactor模式设计的高效事件处理模型
* 文件事务处理器：
  * 多个socket
  * IO多路复用程序
  * 文件事件分派器
  * 事件处理器

# Redis为什么使用单线程
* 使用单线程模型能带来更好的可维护性，方便开发和调试
* 使用单线程模型也能并发的处理客户端的请求
* Redis服务中运行的绝大多数操作的性能瓶颈都不是CPU（决定性），主要在内存和网络
  
# Redis 6.0为什么引入多线程
为了提高网络IO读写性能，但是任务执行还是单线程的。
# 过期数据删除策略
1. 惰性删除：在取出key的时候对数据进行过期检查。对CPU友好，但是会造成太多过期key没有删除。
2. 定期删除：每隔一段事件抽取一批key执行删除过期key操作。
# Redis内存淘汰机制
1. volatile-lru（least recently used）：从已设置过期事件的数据集中挑选最近最少使用的数据淘汰；
2. volatile-ttl：挑选将要过期的数据淘汰
3. volatile-random：从已设置过期的数据集中任意选择数据淘汰；
4. allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最少使用的key（最常用）
5. allkeys-random：从数据集中任意选择数据淘汰
6. no-eviction：禁止驱逐数据，会报错，不淘汰
7. volatile-lfu：从已设置过期时间的数据集中挑选最不常使用的数据淘汰
8. allkeys-lfu：内存不足时，移除最不常用的key
# 为什么执行完命令之后记录日志？
* 避免额外检查开销，AOF记录日志不会对命令进行语法检查；
* 在命令执行完之后再记录，不会阻塞当前命令执行。
* 风险： 执行命令玩宕机导致数据丢失，阻塞后续命令
# AOF 重写
当AOF变得太大时，Redis能够在后台自动重写AOF产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。（BGREWRITEAOF），重写期间，Redis会自动创建一个缓存区保存命令，当重写完成后进行替换加补充。

# RDB（快照持久化） 和 AOF持久化对比
* RDB的内容是经过压缩的二进制数据，保存着完整的数据集，文件很小，适合做数据的备份，灾难恢复。AOF是存储每一次写命令，类似于MySQL的binlog日志，会比RDB大很多。
* RDB的文件恢复速度较快，直接解析即可，而AOF需要依次执行每条命令，写入速度很慢
* RDB数据安全性不如AOF，AOF支持秒级别的数据持久化，而RDB生成快照需要较大资源占用
* 存在老版本Redis不兼容新版RDB格式问题
* AOF便于分析操作
Redis4.0支持RDB和AOF混合持久性记录，在AOF重写时直接把RDB的内容写到AOF的开头。

# Redis 事务
* 通过 `MULTI` `EXEC`命令实现事务开启与提交`DUSCARD`取消事务，`WATCH`被watch的数据在其他线程被修改，则本线程无法提交事务
* Redis事务不满足原子性，提供了一种将多个命令请求打包的功能，不会被中途打断。
* 不建议在日常开发中使用Redis事务，通常使用Lua脚本弥补Redis事务的缺陷。

# Redis性能优化
* 使用批量操作减少网络传输
  * pipeline；
  * Lua脚本；
* 大量key集中过期问题
  * 给key设置随机过期时间；
  * 开启lazy-free（惰性删除/延迟释放），让Redis采用异步方式延迟释放key使用的内存，交给单独的子线程处理，避免阻塞主线程。
* Redis bigkey
  * 使用Redis自带的`--bigkeys`参数查找bigkey
  * 分析RDB文件
* Redis内存碎片：不可用的空闲内存
  * 产生原因：
      1. 存储数据时向操作系统申请的内存空间大于数据实际需要的存储空间
      2. 频繁修改Redis中的数据也会产生内存碎片
# Redis生产问题
* 缓存穿透：大量请求的key是不合理的，根本不存在于缓存中，也不存在于数据库中。
  * 缓存无效key
  * 布隆过滤器
* 缓存击穿：缓存中的数据过期导致大量请求直接访问数据库（热点数据）
  * 设置热点数据永不过期或过期时间较长
  * 针对热点数据提前预热，将其存入缓存并设置合理的的过期时间
  * 请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求回落到数据库上，减少数据库压力。
* 缓存雪崩：缓存在同一时间大面积失效，导致大量请求落到了数据库上。
  * 针对Redis服务不可用的情况：
    * 采用Redis集群，避免单机出现问题整个缓存服务都无法使用
    * 限流，避免同时处理大量的请求
  * 针对热点缓存失效的情况：
    * 设置不同的失效时间，随机设置缓存的失效时间
    * 缓存永不失效（不推荐）
    * 设置二级缓存
* 击穿与雪崩的区别：雪崩导致的原因是缓存中的大量或者所有数据失效，花奴才能击穿导致的原因主要是某个热点数据不存在与缓存中。
